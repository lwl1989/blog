CreateTime:2018-09-12 16:08:59.0

## 堆排序

概念都很模糊，周末要去重看一遍数据结构-树 篇

#### 二叉树

> 堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。

二叉树分类

- 全二叉树（Complete Binary Tree）： 除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。
- 满二叉树（Full Binary Tree）：除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。
- 完满二叉树(Perfect Binary Tree)：除了叶子结点之外的每一个结点都有两个孩子结点。


这里需要纠正一点：

满二叉树和完满二叉树在国内翻译反了，完满二叉树又称为完美二叉树。

完美二叉树

![](https://raw.githubusercontent.com/lwl1989/javaTest/master/static/完美二叉树.png)

满二叉树

![](https://raw.githubusercontent.com/lwl1989/javaTest/master/static/满二叉树.png)

完全二叉树

![](https://raw.githubusercontent.com/lwl1989/javaTest/master/static/完全二叉树.png)

### 完全二叉树特性和特点

> 完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。

##### 性质

1. 具有n个节点的完全二叉树的深度为 k=log2n, n > 2^(k-1)-1

2.【满二叉树】i层的节点数目为：2i

3.【满二叉树】节点总数和深度的关系：n=∑k(i=0)2^i = 2^(k+1)−1

4.【完全二叉树】最后一层的节点数为：n−(2k−1)=n+1−2k （因为除最后一层外，为【满二叉树】）

5.【完全二叉树】左子树的节点数为（总节点为n）：

    l(n) = n-2^(k-1), n+1 - 2^k <= 2^(k-1)
    //因为最后一层全都在左子树，右子树为 满的二叉树 高度为 k-2

    l(n) = 2^k-1,   n+1 - 2^k > 2^(k-1)
    //因为左子树为满二叉树，高度为k-1

6.【完全二叉树】右子树： r(n)=n−l(n)

7.【完全二叉树】子节点 = (父节点 - 1 ） / 2

8.【完全二叉树】父节点 = 子节点 * 2 + 1

......


### 堆排序


最小堆 最小堆任何一个父节点的值，都小于等于它左右孩子节点的值。

最大堆 最大堆任何一个父节点的值，都大于等于它左右孩子节点的值。

整体思想，元素之需要和他的父亲元素进行比较，假如大于/小于父亲元素，则再次对比父亲的元素的父亲，以此类推。因此，比较的最大次数相当于二叉树的深度。


```
      5            5>2 && 2<3 && 2<5  => index变成2的index
    3    2                     比较节点的位置放入2  节点位置改为2的节点位置 并寻找是否有下一个子节点
       6   4       5>3 && 4<6 && 4<5
                               比较节点的位置放入4  节点位置改为4的节点位置 并寻找是否有下一个子节点
    假如孩子节点有右节点 并且 右节点小于左节点  节点转移到右节点位置
```


如图（有点乱）

![](https://raw.githubusercontent.com/lwl1989/javaTest/master/static/排序过程.png)

如果有右子树一定先和右子树进行比较

如果没有右子树则和双亲进行比较

看一张别人的大顶堆排序图：

![](https://raw.githubusercontent.com/lwl1989/javaTest/master/static/别人的大顶堆排序图.png)


[本文代码位置](https://github.com/lwl1989/javaTest/tree/master/src)
