CreateTime:2021-11-26 18:49:51.0

> 本文主要以golang来做代码示例

# 锁

日常生活中，锁无处不见。但是锁的作用呢？比如门锁，车锁，当我们锁门、锁车之后，别人就无法进出房间或者无法进出车辆。当我们对某个事物上锁之后，别人就无法再次使用锁，除非我们进行手动解锁。

从上面的描述，我们可以发现锁有2项关键的操作，上锁、解锁，然后就是对一个核心的对象。

# 计算机中的锁

在我们进行计算机操作的时候，其实底层也实时存在很多的锁。为什么要有锁的存在呢？

![](https://oscimg.oschina.net/oscnet/up-a350a5e9f55acd0f5085346f358fd247e21.png)

其实这个锁的问题，是多核cpu诞生之后才会产生的。

比如上图，我们2个线程同一个内存值进行+1操作,那么这个a最终是多少呢？进行过并发编程的同学们，肯定都知道，答案是无法预测的（难不成我们要，遇事不决，量子力学？）。

```
a = 0
go func(){
    a = a+1
}
go func(){
    a = a+1
}
```

当然量子计算机不在我们的考虑范畴之中，我们回到本题，大家会说，这种操作，我们一般都会通过atomic包进行，但其实，atomic包，通常是归属为sync包中，我们平常用的锁，都是在此包中实现。

当然我们也可以发现，计算机中的锁，就是要解决，多个操作者同一时刻对同一个对象进行操作（改变）的时候，引发的对象的预期结果（状态）不一样的错误。

## 语言中的锁的实现

golang包中自带了sync同步包。其实我们只用看其中一句，最终就是调用的atomic，做的原子操作，然后看预期值是否正确，即上锁成功。
```
// Lock locks m.
// If the lock is already in use, the calling goroutine
// blocks until the mutex is available.
func (m *Mutex) Lock() {
	// Fast path: grab unlocked mutex.
	if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
	//......
```
compareAndswap是什么操作呢？即先和预期值结果比较，如果正确才进行交换。

## 锁会遇到的问题

### 死锁

锁不可怕，在系统运行期间，数据库不停地产生锁，释放锁，是很平常的事情，但是可怕的是死锁（dead lock），发生死锁，会导致多个进程阻塞等待。这时候，数据库会提示“系统在申请资源时，检测到死锁”类似的提示信息。死锁就像十字路口塞车一样，四个方向都走不了。死锁发生有四个必要条件，最后一个，也是最关键的，就是两个事务互相申请被对方持有的资源。

#### 产生死锁的必要条件：

	互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
	请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
	不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
	环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

#### 解决死锁的基本方法

	资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
	只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
	可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
	资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

### 阻塞

阻塞由于资源不足而引起的排队等待现象。在锁的场景下可能是由于上锁的资源释放太慢导致。

## 怎么合理的利用锁

锁主要是用来解决原子性问题，肯定是必不可少的需要用到，那么我们如何来合理的利用锁呢？

- 能不用就不用
- 尽量缩短锁住的时间
- 尽可能粒度更小的

