CreateTime:2019-05-08 21:39:02.0

# finalize

1. java的GC只负责内存相关的清理，所有其它资源的清理必须由程序员手工完成。要不然会引起资源泄露，有可能导致程序崩溃。

2. 调用GC并不保证GC实际执行。

3. finalize抛出的未捕获异常只会导致该对象的finalize执行退出。

4. 用户可以自己调用对象的finalize方法，但是这种调用是正常的方法调用，和对象的销毁过程无关。

5. JVM保证在一个对象所占用的内存被回收之前，如果它实现了finalize方法，则该方法一定会被调用。Object的默认finalize什么都不做，为了效率，GC可以认为一个什么都不做的finalize不存在。


### 作用

1. finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。

2. finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性

3. 不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：

    ① 清理本地对象(通过JNI创建的对象)；
    ② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：
        在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize的问题]

### 毛病

1. 对象必须覆写了finalize()方法

2. finalize()只会在对象内存回收前被调用一次

3. finalize()的调用具有不确定行，只保证方法会调用，但不保证方法里的任务会被执行完（比如一个对象手脚不够利索，磨磨叽叽，还在自救的过程中，被杀死回收了）。

### 总结

finalize()方法并没有什么鸟用，（并且在新版JAVA中已被弃用）。

至于为什么会存在一个鸡肋的方法：书中说“它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协”《JAVA编程思想》。
