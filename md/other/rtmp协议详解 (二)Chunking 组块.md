CreateTime:2020-12-22 18:52:41.0

 > 上文我们经历了rtmp的握手环节，那么接下来我们就可以执行rtmp操作了，也就是本文的主体（消息Message）
 >
 > [rtmp  handshark握手](https://my.oschina.net/lwl1989/blog/4814464)

# 名词解释
        Payload (有效载荷)：包含于一个数据包中的数据，例如音频采样或者压缩的视频数据。payload 的格式和解释，超出了本文档的范围。
        Packet (数据包)：一个数据包由一个固定头和有效载荷数据构成。一些个底层协议可能会要求对数据包定义封装。
        Port (端口)："传输协议用以区分开指定一台主机的不同目的地的一个抽象。TCP/IP 使用小的正整数对端口进行标识。" OSI 传输层使用的运输选择器 (TSEL) 相当于端口。
        Transport address (传输地址)：用以识别传输层端点的网络地址和端口的组合，例如一个 IP 地址和一个 TCP 端口。数据包由一个源传输地址传送到一个目的传输地址。
        Message stream (消息流)：通信中消息流通的一个逻辑通道。
        Message stream ID (消息流 ID)：每个消息有一个关联的 ID，使用 ID 可以识别出流通中的消息流。
        Chunk (块)：消息的一段。消息在网络发送之前被拆分成很多小的部分。块可以确保端到端交付所有消息有序 timestamp，即使有很多不同的流。
        Chunk stream (块流)：通信中允许块流向一个特定方向的逻辑通道。块流可以从客户端流向服务器，也可以从服务器流向客户端。
        Chunk stream ID (块流 ID)：每个块有一个关联的 ID，使用 ID 可以识别出流通中的块流。
        Multiplexing (合成)：将独立的音频/视频数据合成为一个连续的音频/视频流的加工，这样可以同时发送几个视频和音频。
        DeMultiplexing (分解)：Multiplexing 的逆向处理，将交叉的音频和视频数据还原成原始音频和视频数据的格式。
        Remote Procedure Call (RPC 远程方法调用)：允许客户端或服务器调用对端的一个子程序或者程序的请求。
        Metadata (元数据)：关于数据的一个描述。一个电影的 metadata 包括电影标题、持续时间、创建时间等等。
        Application Instance (应用实例)：服务器上应用的实例，客户端可以连接这个实例并发送连接请求。
        Action Message Format (AMF 动作消息格式协议)：一个用于序列化 ActionScript 对象图的紧凑的二进制格式。AMF 有两个版本：AMF 0 [AMF0] 和 AMF 3 [AMF3]。


# 基础结构

RTMP 块流包括其自身的带内协议控制信息，并且提供机制为上层协议植入用户控制消息。

可以被分割为块以支持组合的消息的格式取决于上层协议。消息格式必须包含以下创建块所需的字段。

1. Timestamp：消息的 timestamp。这个字段可以传输四个字节。
2. Length：消息的有效负载长度。如果不能省略掉消息头，那它也被包括进这个长度。这个字段占用了块头的三个字节。
3. Type Id：一些类型 ID 保留给协议控制消息使用。这些传播信息的消息由 RTMP 块流协议和上层协议共同处理。其他的所有类型 ID 可用于上层协议，它们被 RTMP 块流处理为不透明值。事实上，RTMP 块流中没有任何地方要把这些值当做类型使用；所有消息必须是同一类型，或者应用使用这一字段来区分同步跟踪，而不是类型。这一字段占用了块头的一个字节。
4. Message Stream ID：message stream (消息流) ID 可以使任意值。合并到同一个块流的不同的消息流是根据各自的消息流 ID 进行分解。除此之外，对 RTMP 块流而言，这是一个不透明的值。这个字段以小端格式占用了块头的四个字节。

# Chunking （组块）

首先，我们来了解下数据块。

握手之后，连接开始对一个或多个块流进行合并。创建的每个块都有一个唯一 ID 对其进行关联，这个 ID 叫做 chunk stream ID (块流 ID)。这些块通过网络进行传输。传递时，每个块必须被完全发送才可以发送下一块。在接收端，这些块被根据块流 ID 被组装成消息。

分块允许上层协议将大的消息分解为更小的消息，例如，防止体积大的但优先级小的消息 (比如视频) 阻碍体积较小但优先级高的消息 (比如音频或者控制命令)。

分块也让我们能够使用较小开销发送小消息，因为块头包含包含在消息内部的信息压缩提示。

块的大小是可以配置的，下面会详细分析。

	更大的块大小可以降低 CPU 开销，但在低带宽连接时因为它的大量的写入也会延迟其他内容的传递。
	更小的块不利于高比特率的流化。所以块的大小设置取决于具体情况。

## 消息结构Message

#### 块格式

每个块包含一个头和数据体,如下：
```
+--------------+----------------+--------------------+--------------+
 | Basic Header | Message Header | Extended Timestamp | Chunk Data |
 +--------------+----------------+--------------------+--------------+
 | 						      |
 |<------------------- Chunk Header ----------------->|
 ```
块头包含三个部分（Chunk Format）：

1. Basic Header (基本头，1 到 3 个字节)：这个字段对块流 ID 和块类型进行编码。块类型决定了消息头的编码格式。(这一字段的) 长度完全取决于块流 ID，因为块流 ID 是一个可变长度的字段。
2. Message Header (消息头，0，3，7，或者 11 个字节)：这一字段对正在发送的消息 (不管是整个消息，还是只是一小部分) 的信息进行编码。这一字段的长度可以使用块头中定义的块类型进行决定。
3. Extended Timestamp (扩展 timestamp，0 或 4 字节)：这一字段是否出现取决于块消息头中的 timestamp 或者 timestamp delta 字段。更多信息参考 5.3.1.3 节。

而Chunk Data (有效大小)：当前块的有效负载，相当于定义的最大块大小。

#### 块基本头（Basic Header）

块基本头对块流 ID 和块类型 (由下图中的 fmt 字段表示) 进行编码[每个消息命令都会有基本头]。

块基本头字段可能会有 1，2 或者 3 个字节，取决于块流 ID。

一个 (RTMP) 实现应该使用能够容纳这个 ID 的最小的容量进行表示。RTMP 协议最多支持 65597 个流，流 ID 范围 3 - 65599，ID 0、1、2 被保留。


	0 值表示二字节形式，并且 ID 范围 64 - 319 (第二个字节 + 64)。
	1 值表示三字节形式，并且 ID 范围为 64 - 65599 ((第三个字节) * 256 + 第二个字节 + 64)。
	3 - 63 范围内的值表示整个流 ID。
	带有 2 值的块流 ID 被保留，用于下层协议控制消息和命令。

块基本头中的 0 - 5 位 (最低有效) 代表块流 ID。块流 ID 2 - 63 可以编进这一字段的一字节版本中。

```
 0 1 2 3 4 5 6 7
 +-+-+-+-+-+-+-+-+
 |fmt| cs id     |
 +-+-+-+-+-+-+-+-+

 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |fmt| 0       | cs id - 64      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |fmt| 1      | cs id - 64                       |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

#### 消息的头信息（Message Header）

消息的头信息包含了要发送的实际信息（可能是完整的，也可能是一部分）的描述信息。Message Header的格式和长度取决于Basic Header
的chunk type，即fmt，共有四种不同的格式。

其中第一种格式可以表示其他三种表示的所有数据，但由于其他三种格式是基于对之前chunk的差量化的表示，因此可以更简洁地表示相同的数据，实际使用的时候还是应该采用尽量少的字节表示相同意义的数据。

在 chunk 中会有时间戳 timestamp 和时间戳差 timestamp delta(下面的图表会展示)，并且它们不会同时存在，只有这两者之一大于3字节能表示的最大数值 0xFFFFFF ＝ 16777215 时，才会用这个字段来表示真正的时间戳，否则这个字段为 0。扩展时间戳占 4 个字节，能表示的最大数值就是 0xFFFFFFFF ＝ 4294967295。当扩展时间戳启用时，timestamp字段或者timestamp delta要全置为1，而不是减去时间戳或者时间戳差的值。

##### fmt = 0

当fmt为0是，占据11个字节，其他三种能表示的数据它都能表示，是最通用的结构（但在chunk stream 的开始第一个chunk和头信息
### 当fmt为0是，占据11个字节，其他三种能表示的数据它都能表示，是最通用的结构（但在chunk stream 的开始第一个chunk和头信息
中的时间戳后退（即值与上一个chunk相比减小，通常在回退播放的时候会出现这种中的时间戳后退（即值与上一个chunk相比减小，通常在回退播放的时候会出现这种情况）的时候必须采用这种格式）。
```
     0               1               2               3
     0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    timestamp                  |message length |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    message length (coutinue)  |message type id| msg stream id |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                  msg stream id                |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```


	timestamp（时间戳）：占用3个字节，因此它最多能表示到16777215=0xFFFFFF=2^24-1，当它的值超过这个最大值时，这三个字节都置为1，这样实际的timestamp会转存到 ExtendedTimestamp 字段中，接收端在判断timestamp字段24个位都为1时就会去Extended Timestamp中解析实际的时间戳。
	message length（消息数据长度）：占用3个字节，表示实际发送的消息的数据如音频帧、视频帧等数据的长度，单位是字节。注意这里是Message的长度，也就是chunk属于的Message的总长度，而不是chunk本身data的长度。
	message type id(消息的类型id)：1个字节，表示实际发送的数据的类型，如8代表音频数据，9代表视频数据。
	message stream id(消息的流id)：4个字节，表示该chunk所在的流的ID，和Basic Header的CSID一样，它采用小端存储方式。

##### fmt = 1

type为1时占用7个字节，省去了表示message stream id的4个字节，表示此chunk和上一次发的 chunk 所在的流相同，如果在发送端和对端有一个流链接的时候可以尽量采取这种格式。

```
     0               1               2               3
     0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |               timestamp delta                 |message length |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |    message length (coutinue)  |message type id|
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
要注意的是：

这里的timestamp delta：3 bytes，这里和type=0时不同，存储的是和上一个chunk的时间差。类似上面提到的timestamp，当它的值超过3个字节所能表示的最大值时，三个字节都置为1，实际的时间戳差值就会转存到Extended Timestamp字段中，接收端在判断timestamp delta字段24个bit都为1时就会去Extended Timestamp 中解析实际的与上次时间戳的差值。


##### fmt = 2

```
     0               1               2
     0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |               timestamp delta                 |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

type 为 2 时只需占用 3 个字节，相对于 type = 1 格式又省去了表示消息长度的3个字节和表示消息类型的1个字节，表示此 chunk和上一次发送的 chunk 所在的流、消息的长度和消息的类型都相同。余下的这三个字节表示 timestamp delta，使用同type=1。


##### fmt = 3

type=3时，为0字节，表示这个chunk的Message Header和上一个是完全相同的。

当它跟在type=0的chunk后面时，表示和前一个 chunk 的时间戳都是相同。
什么时候连时间戳都是相同呢？

就是一个 Message 拆分成多个 chunk，这个 chunk 和上一个 chunk 同属于一个 Message。

而当它跟在 type = 1或 type = 2 的chunk后面时的chunk后面时，表示和前一个 chunk的时间戳的差是相同的。

比如第一个 chunk 的 type = 0，timestamp = 100，第二个 chunk 的 type = 2，timestamp delta = 20，表示时间戳为 100 + 20 = 120，第三个 chunk 的 type = 3，表示 timestamp delta = 20,时间戳为 120 + 20 = 140。

#### chunk分析(adobo官网示例)

##### demo 1
本示例展示了一个音频消息流。流中包含有冗余信息。
```
    +---------+-----------------+-----------------+-----------------+
    |         |Message Stream ID| Message Type ID | Time  | Length  |
    +---------+-----------------+-----------------+-------+---------+
    | Msg # 1 |    12345        |         8       | 1000  |   32    |
    +---------+-----------------+-----------------+-------+---------+
    | Msg # 2 |    12345        |         8       | 1020  |   32    |
    +---------+-----------------+-----------------+-------+---------+
    | Msg # 3 |    12345        |         8       | 1040  |   32    |
    +---------+-----------------+-----------------+-------+---------+
    | Msg # 4 |    12345        |         8       | 1060  |   32    |
    +---------+-----------------+-----------------+-------+---------+
              Sample audio messages to be made into chunks
```

最后实际发送的chunk如下面表格所示，该表格展示了由此音频流产生的块信息。从第 3 条信息开始，数据传输达到最大优化。每条消息的头部只增加了 1 字节长度。

```
    +--------+---------+-----+------------+------- ---+------------+
    |        | Chunk   |Chunk|Header Data |No.of Bytes|Total No.of |
    |        |Stream ID|Type |            |  After    |Bytes in the|
    |        |         |     |            |Header     |Chunk       |
    +--------+---------+-----+------------+-----------+------------+
    |Chunk#1 |    3    |  0  | delta: 1000|   32      |    44      |
    |        |         |     | length: 32,|           |            |
    |        |         |     | type: 8,   |           |            |
    |        |         |     | stream ID: |           |            |
    |        |         |     | 12345 (11  |           |            |
    |        |         |     | bytes)     |           |            |
    +--------+---------+-----+------------+-----------+------------+
    |Chunk#2 |    3    |  2  | 20 (3      |   32      |    36      |
    |        |         |     | bytes)     |           |            |
    +--------+---------+-----+----+-------+-----------+------------+
    |Chunk#3 |    3    |  3  | none (0    |   32      |    33      |
    |        |         |     | bytes)     |           |            |
    +--------+---------+-----+------------+-----------+------------+
    |Chunk#4 |    3    |  3  | none (0    |   32      |    33      |
    |        |         |     | bytes)     |           |            |
    +--------+---------+-----+------------+-----------+------------+
            Format of each of the chunks of audio messages
```

分析：

1. 上面我们看协议规定了，第一条和最后一条fmt必须为0。

	因此，分片1的数据由  fmt+  header(11 bytes) +32 =44 bytes

2. 看第二个chunk，由于 chunk 的 cs id 和 chunk type id和第一个都一直，因此是fmt=2.

	分片2的数据由  fmt+  header(3 bytes) +32 =36 bytes.

3. 第三个chunk 和第二个 chunk 的 cs id ，chunk type id，以及 data 的长度和时间戳的差值都相同，因此采用 fmt=3.

	分片3的数据由  fmt+32 =36 bytes.

4. 第四个同比第三个一致。

##### demo2

本示例展示了一条长消息，由于消息的长度超过了块的最大长度（128bytes），此消息在传输时将被分割成若干个块。

```
    +-----------+-------------------+-----------------+-----------------+
    |           | Message Stream ID | Message Type ID | Time  | Length  |
    +-----------+-------------------+-----------------+-----------------+
    | Msg # 1   |       12346       |    9 (video)    | 1000  |   307   |
    +-----------+-------------------+-----------------+-----------------+
                    Sample Message to be broken to chunks
```

这个 Message 要分割成三个 chunk 发送：

1. 第一个 chunk：fmt = 0，timestamp = 1000，承担 128 个bytes的 data.

	因此，分片1的数据由  fmt+  header(11 bytes) + 128 =140 bytes

2. 第二个 chunk：同样要发送 128 bytes，其他字段（即Message Header 中的几个字段）都与第一个相同，fmt=3.

	因此，分片2的数据由  fmt+ 128 =129 bytes

3. 第三个 chunk：要发送的 data 的长度为 307 - 128 - 128 = 51 bytes，fmt=3.

	因此，分片2的数据由  fmt+ 51 =129 bytes

```
    +-------+------+-----+-------------+-----------+------------+
    |       |Chunk |Chunk|Header       |No. of     |Total No. of|
    |       |Stream| Type|Data         |Bytes after| bytes in   |
    |       | ID   |     |             | Header    | the chunk  |
    +-------+------+-----+-------------+-----------+------------+
    |Chunk#1|  4   |  0  | delta: 1000 |  128      |   140      |
    |       |      |     | length: 307 |           |            |
    |       |      |     | type: 9,    |           |            |
    |       |      |     | stream ID:  |           |            |
    |       |      |     | 12346 (11   |           |            |
    |       |      |     | bytes)      |           |            |
    +-------+------+-----+-------------+-----------+------------+
    |Chunk#2|  4   |  3  | none (0     |  128      |   129      |
    |       |      |     | bytes)      |           |            |
    +-------+------+-----+-------------+-----------+------------+
    |Chunk#3|  4   |  3  | none (0     |  51       |   52       |
    |       |      |     | bytes)      |           |            |
    +-------+------+-----+-------------+-----------+------------+
                    Format of each of the chunks
```

